<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest of the Crystal Realm - 3D Action RPG</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #000;
        }
        #game-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 3px solid #ffd700;
            border-radius: 10px;
            min-width: 250px;
        }
        #hud h2 {
            color: #ffd700;
            font-size: 18px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px #000;
        }
        .stat-bar {
            margin: 8px 0;
        }
        .stat-label {
            color: #ffd700;
            font-size: 12px;
            margin-bottom: 3px;
        }
        .bar-container {
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #666;
            border-radius: 5px;
            overflow: hidden;
        }
        .bar-fill {
            height: 100%;
            transition: width 0.3s;
        }
        .health-bar {
            background: linear-gradient(to right, #ff0000, #ff6666);
        }
        .exp-bar {
            background: linear-gradient(to right, #0066ff, #6699ff);
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            color: #fff;
            font-size: 14px;
        }
        #inventory {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 3px solid #4169e1;
            border-radius: 10px;
            color: #fff;
            min-width: 200px;
            z-index: 10;
        }
        #inventory h3 {
            color: #4169e1;
            margin-bottom: 10px;
        }
        .item {
            margin: 5px 0;
            padding: 5px;
            background: rgba(65, 105, 225, 0.2);
            border-radius: 5px;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 2px solid #4169e1;
            border-radius: 5px;
            color: #4169e1;
            font-size: 11px;
        }
        #mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            display: none;
            z-index: 1000;
            pointer-events: none;
        }
        #dpad {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }
        .dpad-btn {
            position: absolute;
            width: 40px;
            pointer-events: auto;
            height: 40px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid #fff;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 20px;
            touch-action: none;
        }
        .dpad-btn:active {
            background: rgba(255, 255, 255, 0.6);
        }
        #btn-up { top: 0; left: 40px; }
        #btn-down { bottom: 0; left: 40px; }
        #btn-left { top: 40px; left: 0; }
        #btn-right { top: 40px; right: 0; }
        #attack-btn {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 80px;
            height: 80px;
            background: rgba(255, 0, 0, 0.5);
            border: 3px solid #ff0;
            border-radius: 50%;
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            pointer-events: auto;
        }
        #attack-btn:active {
            background: rgba(255, 0, 0, 0.8);
        }
        #message {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 30px;
            border: 3px solid #ffd700;
            border-radius: 10px;
            color: #ffd700;
            font-size: 16px;
            display: none;
            z-index: 100;
            max-width: 80%;
            text-align: center;
        }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 5px solid #ffd700;
            border-radius: 15px;
            color: #ffd700;
            text-align: center;
            display: none;
            z-index: 200;
        }
        #game-over h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 3px 3px 6px #000;
        }
        #game-over .stats {
            margin: 20px 0;
            color: #fff;
            font-size: 18px;
        }
        #game-over button {
            margin: 10px;
            padding: 15px 30px;
            font-size: 18px;
            background: #ffd700;
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        #game-over button:hover {
            background: #ffed4e;
        }
        @media (max-width: 768px) {
            #mobile-controls { display: block; }
            #controls { display: none; }
            
            #hud {
                font-size: 10px;
                padding: 8px;
                top: 5px;
                left: 5px;
                min-width: 150px;
                max-width: 170px;
            }
            #hud h2 {
                font-size: 12px;
                margin-bottom: 5px;
            }
            .stat-label {
                font-size: 9px;
            }
            .bar-container {
                width: 130px;
                height: 16px;
            }
            .stat-row {
                font-size: 11px;
                margin: 3px 0;
            }
            
            #inventory {
                font-size: 10px;
                padding: 8px;
                top: 5px;
                right: 5px;
                min-width: 120px;
                max-width: 140px;
            }
            #inventory h3 {
                font-size: 11px;
                margin-bottom: 5px;
            }
            .item {
                font-size: 10px;
                padding: 4px;
                margin: 3px 0;
            }
            
            #dpad {
                width: 100px;
                height: 100px;
                bottom: 15px;
                left: 15px;
            }
            .dpad-btn {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
            
            #attack-btn {
                width: 65px;
                height: 65px;
                bottom: 30px;
                right: 20px;
                font-size: 11px;
            }
            
            #message {
                font-size: 13px;
                padding: 10px 20px;
                bottom: 130px;
                max-width: 90%;
            }
            
            #game-over {
                padding: 25px;
                max-width: 90%;
            }
            #game-over h1 {
                font-size: 28px;
                margin-bottom: 15px;
            }
            #game-over .stats {
                font-size: 14px;
                margin: 15px 0;
            }
            #game-over button {
                padding: 12px 20px;
                font-size: 14px;
                margin: 5px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="hud">
        <h2>‚öîÔ∏è HERO STATUS</h2>
        <div class="stat-bar">
            <div class="stat-label">HEALTH</div>
            <div class="bar-container">
                <div class="bar-fill health-bar" id="health-bar" style="width: 100%"></div>
            </div>
        </div>
        <div class="stat-bar">
            <div class="stat-label">EXPERIENCE</div>
            <div class="bar-container">
                <div class="bar-fill exp-bar" id="exp-bar" style="width: 0%"></div>
            </div>
        </div>
        <div class="stat-row">
            <span>LEVEL:</span>
            <span id="level">1</span>
        </div>
        <div class="stat-row">
            <span>ENEMIES:</span>
            <span id="kills">0</span>
        </div>
        <div class="stat-row">
            <span>GOLD:</span>
            <span id="gold">0</span>
        </div>
        <div class="stat-row">
            <span>SCORE:</span>
            <span id="score">0</span>
        </div>
    </div>

    <div id="inventory">
        <h3>üì¶ INVENTORY</h3>
        <div id="items">
            <div class="item">üó°Ô∏è Iron Sword</div>
        </div>
    </div>

    <div id="controls">
        <strong>CONTROLS:</strong><br>
        WASD/Arrows - Move<br>
        SPACE - Attack<br>
        Collect items & defeat enemies!
    </div>

    <div id="mobile-controls">
        <div id="dpad">
            <div class="dpad-btn" id="btn-up">‚ñ≤</div>
            <div class="dpad-btn" id="btn-down">‚ñº</div>
            <div class="dpad-btn" id="btn-left">‚óÄ</div>
            <div class="dpad-btn" id="btn-right">‚ñ∂</div>
        </div>
        <div id="attack-btn">‚öîÔ∏è<br>ATTACK</div>
    </div>

    <div id="message"></div>

    <div id="game-over">
        <h1 id="game-over-title">QUEST COMPLETE!</h1>
        <div class="stats" id="final-stats"></div>
        <button onclick="restart()">PLAY AGAIN</button>
        <button onclick="submitScore()">SUBMIT SCORE</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game state
        let scene, camera, renderer;
        let player, enemies = [], items = [], walls = [];
        let playerHealth = 100, maxHealth = 100;
        let level = 1, exp = 0, expToLevel = 100;
        let kills = 0, gold = 0, score = 0;
        let inventory = ['Iron Sword'];
        let isAttacking = false, canAttack = true;
        let gameOver = false;
        let keys = {};
        let moveDirection = { x: 0, z: 0 };

        // Game constants
        const PLAYER_SPEED = 0.15;
        const ENEMY_SPEED = 0.08;
        const ATTACK_RANGE = 3;
        const MAP_SIZE = 50;

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 10, 60);

            // Orthographic camera for top-down view
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = 20;
            camera = new THREE.OrthographicCamera(
                -viewSize * aspect, viewSize * aspect,
                viewSize, -viewSize,
                0.1, 100
            );
            camera.position.set(0, 20, 0);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Create world
            createGround();
            createPlayer();
            createWalls();
            spawnEnemies(5);
            spawnItems(10);

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                if (e.key === ' ' && canAttack) attack();
            });
            window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

            setupMobileControls();

            animate();
        }

        function createGround() {
            // Grass ground
            const groundGeom = new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE);
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x228b22,
                roughness: 0.8
            });
            const ground = new THREE.Mesh(groundGeom, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Grid pattern
            const gridHelper = new THREE.GridHelper(MAP_SIZE, MAP_SIZE, 0x444444, 0x444444);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
        }

        function createPlayer() {
            player = new THREE.Group();

            // Body
            const bodyGeom = new THREE.BoxGeometry(1, 1.5, 0.8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x4169e1 });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = 0.75;
            body.castShadow = true;
            player.add(body);

            // Head
            const headGeom = new THREE.SphereGeometry(0.4);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeom, headMat);
            head.position.y = 1.8;
            head.castShadow = true;
            player.add(head);

            // Sword (initially hidden)
            const swordGeom = new THREE.BoxGeometry(0.2, 1.5, 0.1);
            const swordMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0 });
            const sword = new THREE.Mesh(swordGeom, swordMat);
            sword.position.set(0.6, 1, 0);
            sword.visible = false;
            player.add(sword);
            player.sword = sword;

            player.position.set(0, 0, 0);
            scene.add(player);
        }

        function createWalls() {
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            
            // Outer walls
            const wallPositions = [
                { x: 0, z: MAP_SIZE/2, w: MAP_SIZE, h: 2, d: 1 },
                { x: 0, z: -MAP_SIZE/2, w: MAP_SIZE, h: 2, d: 1 },
                { x: MAP_SIZE/2, z: 0, w: 1, h: 2, d: MAP_SIZE },
                { x: -MAP_SIZE/2, z: 0, w: 1, h: 2, d: MAP_SIZE }
            ];

            wallPositions.forEach(pos => {
                const wallGeom = new THREE.BoxGeometry(pos.w, pos.h, pos.d);
                const wall = new THREE.Mesh(wallGeom, wallMat);
                wall.position.set(pos.x, 1, pos.z);
                wall.castShadow = true;
                wall.receiveShadow = true;
                walls.push(wall);
                scene.add(wall);
            });

            // Interior obstacles
            for (let i = 0; i < 15; i++) {
                const size = Math.random() * 2 + 1;
                const wallGeom = new THREE.BoxGeometry(size, 2, size);
                const wall = new THREE.Mesh(wallGeom, wallMat);
                wall.position.set(
                    (Math.random() - 0.5) * (MAP_SIZE - 10),
                    1,
                    (Math.random() - 0.5) * (MAP_SIZE - 10)
                );
                wall.castShadow = true;
                wall.receiveShadow = true;
                walls.push(wall);
                scene.add(wall);
            }
        }

        function spawnEnemies(count) {
            const enemyTypes = [
                { color: 0xff0000, health: 30, damage: 10, exp: 20, gold: 5 },
                { color: 0x800080, health: 50, damage: 15, exp: 35, gold: 10 },
                { color: 0x000000, health: 80, damage: 25, exp: 60, gold: 20 }
            ];

            for (let i = 0; i < count; i++) {
                const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                const enemy = new THREE.Group();

                const bodyGeom = new THREE.BoxGeometry(0.8, 1.2, 0.8);
                const bodyMat = new THREE.MeshStandardMaterial({ color: type.color });
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.position.y = 0.6;
                body.castShadow = true;
                enemy.add(body);

                const headGeom = new THREE.SphereGeometry(0.35);
                const head = new THREE.Mesh(headGeom, bodyMat);
                head.position.y = 1.4;
                head.castShadow = true;
                enemy.add(head);

                enemy.position.set(
                    (Math.random() - 0.5) * (MAP_SIZE - 15),
                    0,
                    (Math.random() - 0.5) * (MAP_SIZE - 15)
                );

                enemy.health = type.health;
                enemy.maxHealth = type.health;
                enemy.damage = type.damage;
                enemy.exp = type.exp;
                enemy.gold = type.gold;
                enemy.speed = ENEMY_SPEED + Math.random() * 0.03;

                enemies.push(enemy);
                scene.add(enemy);
            }
        }

        function spawnItems(count) {
            const itemTypes = [
                { color: 0xffd700, name: 'Gold Coin', value: 10 },
                { color: 0xff0000, name: 'Health Potion', value: 30 },
                { color: 0x00ffff, name: 'Magic Crystal', value: 50 }
            ];

            for (let i = 0; i < count; i++) {
                const type = itemTypes[Math.floor(Math.random() * itemTypes.length)];
                const itemGeom = new THREE.OctahedronGeometry(0.5);
                const itemMat = new THREE.MeshStandardMaterial({ 
                    color: type.color,
                    emissive: type.color,
                    emissiveIntensity: 0.3
                });
                const item = new THREE.Mesh(itemGeom, itemMat);
                item.position.set(
                    (Math.random() - 0.5) * (MAP_SIZE - 10),
                    0.5,
                    (Math.random() - 0.5) * (MAP_SIZE - 10)
                );
                item.castShadow = true;
                item.itemType = type.name;
                item.value = type.value;
                items.push(item);
                scene.add(item);
            }
        }

        function updatePlayer() {
            if (gameOver) return;

            moveDirection.x = 0;
            moveDirection.z = 0;

            if (keys['w'] || keys['arrowup']) moveDirection.z -= 1;
            if (keys['s'] || keys['arrowdown']) moveDirection.z += 1;
            if (keys['a'] || keys['arrowleft']) moveDirection.x -= 1;
            if (keys['d'] || keys['arrowright']) moveDirection.x += 1;

            // Normalize diagonal movement
            if (moveDirection.x !== 0 && moveDirection.z !== 0) {
                moveDirection.x *= 0.707;
                moveDirection.z *= 0.707;
            }

            const newX = player.position.x + moveDirection.x * PLAYER_SPEED;
            const newZ = player.position.z + moveDirection.z * PLAYER_SPEED;

            // Collision detection
            if (!checkCollision(newX, newZ, 0.5)) {
                player.position.x = newX;
                player.position.z = newZ;
            }

            // Face movement direction
            if (moveDirection.x !== 0 || moveDirection.z !== 0) {
                player.rotation.y = Math.atan2(moveDirection.x, moveDirection.z);
            }

            // Camera follows player
            camera.position.x = player.position.x;
            camera.position.z = player.position.z;
        }

        function checkCollision(x, z, radius) {
            for (let wall of walls) {
                const dx = Math.abs(x - wall.position.x);
                const dz = Math.abs(z - wall.position.z);
                const wallSize = wall.geometry.parameters.width / 2;
                if (dx < wallSize + radius && dz < wallSize + radius) {
                    return true;
                }
            }
            return false;
        }

        function updateEnemies() {
            enemies.forEach((enemy, index) => {
                // Move towards player
                const dx = player.position.x - enemy.position.x;
                const dz = player.position.z - enemy.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist > 1.5) {
                    enemy.position.x += (dx / dist) * enemy.speed;
                    enemy.position.z += (dz / dist) * enemy.speed;
                    enemy.rotation.y = Math.atan2(dx, dz);
                }

                // Attack player if close
                if (dist < 2 && Math.random() < 0.02) {
                    playerHealth -= enemy.damage;
                    updateHUD();
                    if (playerHealth <= 0) {
                        endGame('GAME OVER');
                    }
                }

                // Rotate for effect
                enemy.children[0].rotation.y += 0.02;
            });
        }

        function updateItems() {
            items.forEach((item, index) => {
                item.rotation.y += 0.05;
                item.position.y = 0.5 + Math.sin(Date.now() * 0.003) * 0.2;

                const dx = player.position.x - item.position.x;
                const dz = player.position.z - item.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < 1.5) {
                    collectItem(item, index);
                }
            });
        }

        function collectItem(item, index) {
            scene.remove(item);
            items.splice(index, 1);

            if (item.itemType === 'Gold Coin') {
                gold += item.value;
                score += item.value;
                showMessage('Found ' + item.value + ' Gold!');
            } else if (item.itemType === 'Health Potion') {
                playerHealth = Math.min(maxHealth, playerHealth + item.value);
                showMessage('Health +' + item.value);
            } else if (item.itemType === 'Magic Crystal') {
                exp += item.value;
                score += item.value * 2;
                inventory.push(item.itemType);
                showMessage('Found Magic Crystal!');
                checkLevelUp();
            }

            updateHUD();

            // Spawn new item
            if (items.length < 8) {
                setTimeout(() => spawnItems(1), 2000);
            }
        }

        function attack() {
            if (!canAttack || isAttacking) return;

            isAttacking = true;
            canAttack = false;
            player.sword.visible = true;

            // Check for enemy hits
            enemies.forEach((enemy, index) => {
                const dx = player.position.x - enemy.position.x;
                const dz = player.position.z - enemy.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < ATTACK_RANGE) {
                    const damage = 20 + level * 5;
                    enemy.health -= damage;

                    // Flash red
                    enemy.children[0].material.emissive = new THREE.Color(0xff0000);
                    enemy.children[0].material.emissiveIntensity = 0.5;
                    setTimeout(() => {
                        if (enemy.children[0]) {
                            enemy.children[0].material.emissiveIntensity = 0;
                        }
                    }, 100);

                    if (enemy.health <= 0) {
                        scene.remove(enemy);
                        enemies.splice(index, 1);
                        kills++;
                        exp += enemy.exp;
                        gold += enemy.gold;
                        score += enemy.exp + enemy.gold * 2;
                        showMessage('Enemy Defeated! +' + enemy.exp + ' EXP');
                        checkLevelUp();
                        updateHUD();

                        // Spawn new enemy
                        if (enemies.length < 3) {
                            setTimeout(() => spawnEnemies(1), 3000);
                        }
                    }
                }
            });

            setTimeout(() => {
                isAttacking = false;
                player.sword.visible = false;
            }, 300);

            setTimeout(() => {
                canAttack = true;
            }, 500);
        }

        function checkLevelUp() {
            if (exp >= expToLevel) {
                level++;
                exp = 0;
                expToLevel = Math.floor(expToLevel * 1.5);
                maxHealth += 20;
                playerHealth = maxHealth;
                showMessage('LEVEL UP! Now Level ' + level);
                updateHUD();
            }
        }

        function updateHUD() {
            document.getElementById('health-bar').style.width = (playerHealth / maxHealth * 100) + '%';
            document.getElementById('exp-bar').style.width = (exp / expToLevel * 100) + '%';
            document.getElementById('level').textContent = level;
            document.getElementById('kills').textContent = kills;
            document.getElementById('gold').textContent = gold;
            document.getElementById('score').textContent = score;
        }

        function showMessage(text) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.style.display = 'block';
            setTimeout(() => {
                msg.style.display = 'none';
            }, 2000);
        }

        function endGame(title) {
            gameOver = true;
            document.getElementById('game-over-title').textContent = title;
            document.getElementById('final-stats').innerHTML = `
                <div>Level Reached: ${level}</div>
                <div>Enemies Defeated: ${kills}</div>
                <div>Gold Collected: ${gold}</div>
                <div>Final Score: ${score}</div>
            `;
            document.getElementById('game-over').style.display = 'block';
        }

        function restart() {
            location.reload();
        }

        function submitScore() {
            const urlParams = new URLSearchParams(window.location.search);
            const gameId = urlParams.get('gameId');
            
            window.parent.postMessage({
                type: 'SUBMIT_SCORE',
                gameId: gameId,
                score: score,
                metadata: {
                    level: level,
                    kills: kills,
                    gold: gold
                }
            }, '*');
            
            document.getElementById('game-over').style.display = 'none';
            restart();
        }

        function setupMobileControls() {
            const dpadButtons = {
                'btn-up': () => { keys['w'] = true; setTimeout(() => keys['w'] = false, 100); },
                'btn-down': () => { keys['s'] = true; setTimeout(() => keys['s'] = false, 100); },
                'btn-left': () => { keys['a'] = true; setTimeout(() => keys['a'] = false, 100); },
                'btn-right': () => { keys['d'] = true; setTimeout(() => keys['d'] = false, 100); }
            };

            Object.keys(dpadButtons).forEach(id => {
                const btn = document.getElementById(id);
                let interval;
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    interval = setInterval(dpadButtons[id], 50);
                });
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    clearInterval(interval);
                });
            });

            document.getElementById('attack-btn').addEventListener('touchend', (e) => {
                e.preventDefault();
                if (canAttack) attack();
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            updatePlayer();
            updateEnemies();
            updateItems();
            
            renderer.render(scene, camera);

            // Auto end after 10 minutes or level 10
            if (level >= 10 || Date.now() - startTime > 600000) {
                if (!gameOver) endGame('VICTORY!');
            }
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = 20;
            camera.left = -viewSize * aspect;
            camera.right = viewSize * aspect;
            camera.top = viewSize;
            camera.bottom = -viewSize;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        const startTime = Date.now();
        init();
    </script>
</body>
</html>
